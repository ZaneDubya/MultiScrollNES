MiniC is a hypothetical C-like language for the 6502. It uses a pseudostack to give functions fast access to parameters and local values.

=== Program Structure ===
Comments
    //
    /* ... */

Preprocessor directives
    .include
    .incbin
    .require
    .db
    .dw
    .asm
    .endasm
    
Labels
    Label:
    
Global Declarations
    byte i;                         unsigned byte variables (8-bit), may have initial value
    word i;                         unsigned word variables (16-bit), may have initial value
    const byte i = 1;               constants of unsigned bytes or words
    byte[x] i or word[x] i;         arrays of unsigned bytes or words
    byte* i or word* i;             pointers to unsigned bytes or words
    f(...)                          functions
    
Functions
    Must occur at global level, outside of other function declarations.
    Consist of two parts: declarator and body.
    Declarator states name, names and types of parameter arguments within required parenthasis pair.
        void func(byte i)
        byte func()
        word func(word i, byte i)
    Body consists of statement between brackets that does function work.
        { and }
        Compound statements (nested brackets) are allowed.
    Flow of Control
        Execution begins with first statement.
        Execution ends with return or at closing body bracket.
        Functions returning a value must have a "return x" statement.
        Functions returning void must have no return statement.
        Return value is at top of fake stack.

Global variables
    Variables outside of a function are accessible by any function.

Example:
void main() {
    byte a = 1;
    byte b = 2;
    byte c = 3;
    byte d = dosomething(a, b, c);
}

byte dosomething(byte a, byte b, byte c) {
    byte d = a + b + c;
    return d;
}

// main: fsb = 0, fss = 4, 0 in
ldx #$00
lda #$01
sta $00,x
lda #$02
sta $01,x
lda #$03
sta $02,x
// call dosomething
txa
pha
tay
clc
adc #$04
tax
lda #$0000,y
sta $00,x
lda #$0001,y
sta $01,x
lda #$0002,y
sta $02,x
jsr dosomething
lda memory_return
sta $03,x
// end main

// dosomething: fss = 4, 3 in
lda $02,x
clc
adc $01,x
clc
adc $00,x
sta $03,x       \__ Optimize out, and reduce fss as this variable is otherwise unused.
lda $03,x       /
sta memory_return
pla
tax
rts
// end dosomething
