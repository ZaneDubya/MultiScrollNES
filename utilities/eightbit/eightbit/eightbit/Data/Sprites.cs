using eightbit.Data.SpriteData;
using System;
using System.Collections.Generic;

namespace eightbit.Data
{
    class Sprites
    {
        private const string c_SerializeIdentifier = "Sprites";
        private List<Sprite> m_Sprites = new List<Sprite>();

        public Sprites()
        {

        }

        public int Count
        {
            get { return m_Sprites.Count; }
        }

        public Sprite this[int index]
        {
            get
            {
                if (index < 0 || index >= m_Sprites.Count)
                    return null;
                return m_Sprites[index];
            }
        }

        public void AddSprite()
        {
            Sprite s = new Sprite();
            m_Sprites.Add(s);
        }

        public void RemoveLastSprite()
        {
            if (m_Sprites.Count > 0)
                m_Sprites.RemoveAt(m_Sprites.Count - 1);
        }

        public bool Unserialize(Core.BinaryFileReader reader)
        {
            string id = reader.ReadString();
            if (id != c_SerializeIdentifier)
                return false;
            int version = reader.ReadInt();

            // version 0
            int count = reader.ReadInt();
            for (int i = 0; i < count; i++)
            {
                Sprite sprite = new Sprite();
                sprite.Unserialize(reader, version);
                m_Sprites.Add(sprite);
            }

            return true;
        }

        public void Serialize(Core.BinaryFileWriter writer)
        {
            int version = 1;

            writer.Write(c_SerializeIdentifier);
            writer.Write((int)version); // version
            writer.Write(Count);
            for (int i = 0; i < Count; i++)
            {
                m_Sprites[i].Serialize(writer, version);
            }
        }

        public void Export(int tiledata_base_offset, int tiledata_max_size, int header_count, Core.BinaryFileWriter header_writer, Core.BinaryFileWriter tiledata_writer)
        {
            int maxTileDataOffset = tiledata_base_offset + tiledata_max_size;
            int currentTiledataOffset = tiledata_base_offset;

            byte[] header_data = new byte[Count * 4];

            for (int i = 0; i < Count; i++)
            {
                Tuple<byte, byte>[] tile_transform_table = m_Sprites[i].TileTransformTable;

                ushort tiledataOffset = CreateTileDataOffset(ref currentTiledataOffset, m_Sprites[i], tile_transform_table, maxTileDataOffset);

                // sprite header data: 4b per sprite. REFERENCE ref.data\Engines\Sprite Data.txt
                byte dataByte = (byte)m_Sprites[i].DataByte;
                byte tileByte = (byte)(createTileDataByte(tile_transform_table) | m_Sprites[i].TileByte);

                header_data[i * 4 + 0] = ((byte)(tiledataOffset & 0x00ff));
                header_data[i * 4 + 1] = ((byte)((tiledataOffset & 0xff00) >> 8));
                header_data[i * 4 + 2] = (dataByte); // wTss xfff
                header_data[i * 4 + 3] = (tileByte); // yxMM cccc

                // metasprite/chr tile index data.
                m_Sprites[i].ExportMetaSprites(tiledata_writer, tile_transform_table);
                for (int j = 0; j < tile_transform_table.Length; j++)
                {
                    tiledata_writer.Write((byte)tile_transform_table[j].Item1); // tile
                    tiledata_writer.Write((byte)tile_transform_table[j].Item2); // page

                }
            }

            header_writer.WriteString("; Sprite Header data. Generated by eightbit.\n");
            header_writer.WriteString("; Format described in Sprite Data.txt\n\n");

            header_writer.WriteString("SpriteHdrs_Address:\n");
            for (int i = 0; i < header_count; i++)
            {
                if (i % 8 == 0)
                    header_writer.WriteString("    .byte ");
                byte data = (i < Count) ? header_data[i * 4 + 0] : (byte)0;
                header_writer.WriteString(string.Format("${0:X2}", data));
                if (i % 8 == 7)
                    header_writer.WriteString("\n");
                else
                    header_writer.WriteString(", ");
            }

            header_writer.WriteString("SpriteHdrs_AddressHi:\n");
            for (int i = 0; i < header_count; i++)
            {
                if (i % 8 == 0)
                    header_writer.WriteString("    .byte ");
                byte data = (i < Count) ? header_data[i * 4 + 1] : (byte)0;
                header_writer.WriteString(string.Format("${0:X2}", data));
                if (i % 8 == 7)
                    header_writer.WriteString("\n");
                else
                    header_writer.WriteString(", ");
            }

            header_writer.WriteString("SpriteHdrs_Data:\n");
            for (int i = 0; i < header_count; i++)
            {
                if (i % 8 == 0)
                    header_writer.WriteString("    .byte ");
                byte data = (i < Count) ? header_data[i * 4 + 2] : (byte)0;
                header_writer.WriteString(string.Format("${0:X2}", data));
                if (i % 8 == 7)
                    header_writer.WriteString("\n");
                else
                    header_writer.WriteString(", ");
            }

            header_writer.WriteString("SpriteHdrs_Tile:\n");
            for (int i = 0; i < header_count; i++)
            {
                if (i % 8 == 0)
                    header_writer.WriteString("    .byte ");
                byte data = (i < Count) ? header_data[i * 4 + 3] : (byte)0;
                header_writer.WriteString(string.Format("${0:X2}", data));
                if (i % 8 == 7)
                    header_writer.WriteString("\n");
                else
                    header_writer.WriteString(", ");
            }
        }

        private ushort CreateTileDataOffset(ref int offset, Sprite sprite, Tuple<byte, byte>[] sprite_transform_table, int max_offset)
        {
            if (offset >= max_offset)
                throw new Exception(string.Format("Bad Sprite MetaTile offset size. Too large for specified max_offset size of {0}.", max_offset));

            ushort data = (ushort)offset;
            offset += sprite.MetaDataSize + sprite_transform_table.Length * 2;

            return data;
        }

        private byte createTileDataByte(Tuple<byte, byte>[] tile_transform_table)
        {
            byte tile_count = (byte)(tile_transform_table.Length > 0 ? tile_transform_table.Length - 1 : 0);
            byte data = (byte)((tile_count & 0x3f) << 2);
            return data;
        }

        public Sprite[] ToArray()
        {
            return m_Sprites.ToArray();
        }
    }
}
